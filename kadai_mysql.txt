＞Q1：選択したストレージエンジンに関わらずテーブルロックが行われる代表的なクエリは何か？

ALTER TABLE
LOCK TABLE


Q2：Q1を踏まえた上で、実運用上で注意すべき事は何か？
ロックされたまま放置されるとデータの更新がされないまま処理が止まってしまうなどのトラブルが起きるので、タイムアウトの設定や、排他ロックを必要最小限のデータに適用させる。
また、あるトランザクションがテーブルをロックした状態で他のトランザクションからのロックリクエストがかるとデッドロック状態になってしまうので、予めタイムアウトを設定したり、ロックする順番を設定しておく。


Q3：並行性が最も高いInnoDBでサポートされるロック方式は何か？
行ロック

Q4：トランザクションは主に４つの条件を満たす為に実装される、その４つの頭文字を取って何と呼ばれるか？
ACID


Q5：Q4で答えた４つの条件について、それぞれ具体的な条件は何か？
アトミック性（分割できない作業単位であること）
一貫性（予期されないのデータ矛盾が発生しない）
分離性（他の処理から見えない、影響を与えない）
永続性（コミットされたらデータの更新は持続される、回復できる）


Q6：InnoDBにおいて、ある行に対して更新が行われている最中に他のプロセスが同じ行を更新しようとし、お互いのプロセスが待ち続ける現象を何と言うか？
デッドロック

Q7：MyISAMは現在では積極的に選択される事がすくないが、その最たる原因は何か？
トランザクション処理ができない→ロールバックができない。
データをクラッシュした時など復旧しにくい。


Q8：MySQLで用いられる以下の型を定義する時のキーワードは何か？
整数型、文字型、論理型、時刻型、列挙型、アンパック浮動小数点型

INT
CHAR,VARCHAR
BOOLEAN
DATE
ENUM
DECIMAL




Q9：下記のテーブル構造は非正規である、正規形にするにはどうすれば良いか？
employee_table
id, name, department
1, yokozawa, dev
2, nagashima, dev
3, kitano, ope
4, hamda, ope

テーブルをわける。
employee
id, name
1, yokozawa
2, nagashima
3, kitano
4, hamda

employee_department
iemployee_id, department
001,dev
002,dev
003,ope
004,ope



Q10：非正規化されたテーブル構造を意図的に利用する場合に期待する最も大きな利点は何か？
テーブルを結合する必要がないため、効率的なインデックスが可能。
Aテーブルに持つ属性を、Bテーブルに切り離した場合、その属性が参照される頻度が多い場合はAテーブルとしてまとめたほうが効率的なインデックスという観点では良い。

Q11：1..10までのRuby配列がある場合に線形探索で7を探しだす場合の比較回数は何回か？
７回

Q12：1..10までのRuby配列がある場合に二分木探索で7を探しだす場合の比較回数は何回か？
３回

Q13：Q9で正規化されたテーブル構造について、２分木インデックスを適用するのはどのカラムにするべきか？
id
もしくは
iemployee_id



Q14：EXPLAINにおけるtype句で何が指定されている場合に適切なインデクシングがされていると言えるか？
const


Q15：下記のクエリは典型的なマズいサブクエリです、何がマズイのかEXPLAINの結果を元に説明してください。


select * from customers
where id in (
select customer_id
from customer_messages
where body like '%ああ%'
)



Q16：Q15のクエリを効率的に書きなおして下さい。
select * from customers cus
inner join customer_messages cus_mes
on cus_mes.customer_id = cus.id
where body like '%ああ%'
